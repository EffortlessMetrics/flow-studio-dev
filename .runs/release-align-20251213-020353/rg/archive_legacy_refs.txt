tests/test_flow_studio_ui_ids.py:574:            "Search input should have legacy id for backwards compatibility"
docs/PACKAGING_NOTES.md:51:- **Flask backend** (`swarm/tools/flow_studio_flask.py`) — legacy, not extracted
docs/specs/TIMELINE_OVERLAYS_SPEC.md:8:- Flask backend (legacy): `swarm/tools/flow_studio.py`
swarm/SELFTEST_SYSTEM_DOC_UPDATES.md:18:  - JSON report schema (both V1 legacy and V2 formats)
swarm/SELFTEST_SYSTEM_DOC_UPDATES.md:52:  - JSON output (V1 legacy and V2 with severity/category breakdown)
swarm/SELFTEST_SYSTEM_DOC_UPDATES.md:71:  - V1 legacy format (backward compatible)
docs/VALIDATION_RULES.md:278:**Description**: Validates that deprecated microloop phrases are not used. Enforces new iteration logic based on explicit `Status` and `can_further_iteration_help` signals.
swarm/runtime/storage.py:21:        list_runs, discover_legacy_runs,
swarm/runtime/storage.py:533:def discover_legacy_runs(runs_dir: Path = RUNS_DIR) -> List[RunId]:
swarm/runtime/storage.py:534:    """Find runs that have flow artifacts but no meta.json (legacy runs).
swarm/runtime/storage.py:544:        List of run IDs that appear to be legacy runs.
swarm/runtime/storage.py:552:    legacy_runs: List[RunId] = []
swarm/runtime/storage.py:557:        # Skip if already has meta.json (not legacy)
swarm/runtime/storage.py:567:            legacy_runs.append(entry.name)
swarm/runtime/storage.py:569:    return sorted(legacy_runs)
swarm/runtime/storage.py:576:    They are always treated as legacy (no meta.json expected).
swarm/runtime/storage.py:647:    for run_id in discover_legacy_runs():
swarm/tools/run_layout_review.py:257:    NOTE: This is a legacy wrapper. Prefer capture_with_playwright() for
swarm/runtime/service.py:165:        include_legacy: bool = True,
swarm/runtime/service.py:172:            include_legacy: Include runs without meta.json (legacy runs).
swarm/runtime/service.py:187:                summary = self._create_legacy_summary(rid, is_example=True)
swarm/runtime/service.py:203:        # Include legacy runs if requested
swarm/runtime/service.py:204:        if include_legacy:
swarm/runtime/service.py:205:            for rid in storage.discover_legacy_runs():
swarm/runtime/service.py:208:                # Create minimal summary for legacy runs
swarm/runtime/service.py:209:                summary = self._create_legacy_summary(rid, is_example=False)
swarm/runtime/service.py:223:    def _create_legacy_summary(
swarm/runtime/service.py:228:        """Create a summary for a legacy run (no meta.json).
swarm/runtime/service.py:265:        tags = ["example"] if is_example else ["legacy"]
swarm/runtime/service.py:281:                logger.warning("Failed to read legacy run metadata for %s: %s", run_id, e)
swarm/runtime/service.py:289:                initiator="example" if is_example else "legacy",
swarm/tools/runs_gc.py:60:    run_type: str  # "active", "example", "legacy"
swarm/tools/runs_gc.py:153:                    runs.append(get_run_info(entry.name, entry, "legacy"))
swarm/tools/runs_gc.py:215:    legacy = [r for r in runs if r.run_type == "legacy"]
swarm/tools/runs_gc.py:224:    logger.info(f"  Legacy:       {len(legacy)}")
swarm/tools/flow_studio_fastapi.py:509:                        include_legacy=True,
swarm/tools/flow_studio_fastapi.py:539:                        filtered_tags = [t for t in summary.tags if t not in ("example", "legacy")]
swarm/tools/flow_studio_fastapi.py:547:                        "RunService.list_runs failed, falling back to legacy inspector: %s",
swarm/tools/selftest_config.py:157:            "uv run python -m compileall -x '_archive' swarm/tools swarm/validator",
docs/archive/FLOW_STUDIO_SELFTEST_ENHANCEMENTS.md:212:   - Flask (legacy): `swarm/tools/flow_studio.py`
docs/archive/FLOW_STUDIO_SELFTEST_ENHANCEMENTS.md:232:- `<repo-root>/swarm/tools/flow_studio.py` (Flask backend, legacy)
tests/test_run_service.py:207:    def test_discover_legacy_runs(self, tmp_path):
tests/test_run_service.py:209:        # Create a legacy run (has signal/ dir but no meta.json)
tests/test_run_service.py:210:        legacy_path = tmp_path / "legacy-run"
tests/test_run_service.py:211:        (legacy_path / "signal").mkdir(parents=True)
tests/test_run_service.py:225:        legacy = storage.discover_legacy_runs(runs_dir=tmp_path)
tests/test_run_service.py:226:        assert "legacy-run" in legacy
tests/test_run_service.py:227:        assert "normal-run" not in legacy
docs/archive/design_validation.md:66:- `test_flow_studio_governance.py` (Flask) — mark as deprecated but keep
docs/archive/design_validation.md:184:5. Mark Flask version as deprecated
docs/archive/design_validation.md:188:5. **Keep Flask tests**: Rename to `test_flow_studio_governance_flask.py`, mark as deprecated
swarm/config/runtime_config.py:204:    2. SWARM_GEMINI_STUB (legacy, for gemini only) - "1" means stub mode
swarm/config/runtime_config.py:224:    # 2. Check legacy SWARM_GEMINI_STUB for gemini (backward compatibility)
swarm/config/runtime_config.py:226:        legacy_stub = os.environ.get("SWARM_GEMINI_STUB")
swarm/config/runtime_config.py:227:        if legacy_stub is not None:
swarm/config/runtime_config.py:228:            return "stub" if legacy_stub == "1" else "real"
docs/archive/FLOW3_CONTEXT_INDEX.md:36:| **5** | `.github/workflows/swarm-validate.yml` | v4 deprecated, `\|\| true` masks failures | Update + fix + add cache |
docs/archive/FLOW3_CONTEXT_INDEX.md:123:- **Why:** v4 is deprecated; v5 is current
tests/API_COHERENCE_CONTRACT.md:46:- `FAIL`: Generic failure (legacy)
swarm/tools/_archive/flow_studio_flask_legacy.py:9:This file is preserved for reference only. It shows the legacy Flask
swarm/tools/_archive/flow_studio_flask_legacy.py:15:DO NOT USE THIS FILE IN PRODUCTION.
docs/archive/WORKFLOW_CONTEXT_LOADER_OUTPUT.md:37:   - Issues: setup-python v4 (deprecated), backup step masks failures, missing cache
docs/archive/WORKFLOW_CONTEXT_LOADER_OUTPUT.md:222:        uses: actions/setup-python@v4  # <-- ISSUE: v4 is deprecated, should be v5
docs/archive/WORKFLOW_CONTEXT_LOADER_OUTPUT.md:253:- Line 33: `actions/setup-python@v4` (deprecated, should be v5)
swarm/tools/validate_swarm.py:1632:    Validate that deprecated microloop phrases are not used.
docs/FLOW_STUDIO_REFACTOR.md:561:- [x] Create `js/flow-studio-app.js` (originally `flow-studio-legacy.js`) and move `<script>…</script>` into it (3068 lines).
tests/test_run_inspector.py:61:34. test_get_run_timeline_legacy_format - Parses legacy execution_timeline format
tests/test_run_inspector.py:174:    Forces RunInspector.list_runs() to use the legacy implementation which
tests/test_run_inspector.py:194:    # Force RunInspector.list_runs() to use the legacy implementation
tests/test_run_inspector.py:196:        return self._list_runs_legacy()
tests/test_run_inspector.py:220:    Forces RunInspector.list_runs() to use the legacy implementation which
tests/test_run_inspector.py:238:    # Force RunInspector.list_runs() to use the legacy implementation
tests/test_run_inspector.py:241:        return self._list_runs_legacy()
tests/test_run_inspector.py:868:    def test_get_run_timeline_legacy_format(self, temp_repo, inspector):
tests/test_run_inspector.py:869:        """Parses legacy execution_timeline format."""
docs/RUN_LIFECYCLE.md:369:Runs created before the RunService may lack metadata. These are detected by `discover_legacy_runs()` and shown with `has_meta: false`. They function normally but lack timing/status data.
docs/MAINTAINING_FLOW_STUDIO.md:193:- Legacy Flask backend archived in `swarm/tools/_archive/`
docs/MAINTAINING_FLOW_STUDIO.md:197:2. Only edit files under `swarm/tools/_archive/` (legacy reference)
docs/MAINTAINING_FLOW_STUDIO.md:346:3. Move Flask code to `swarm/tools/_archive/` if needed
docs/MAINTAINING_FLOW_STUDIO.md:405:- **v2.1.x**: Dual Flask/FastAPI backends (deprecated)
docs/archive/TRACK_2_IMPLEMENTATION.md:192:6. **Side-by-Side Deployment**: Flask and FastAPI can run side-by-side. Flask is not deprecated; users can choose based on their preferences.
docs/FLOW_STUDIO_API.md:13:> **Note**: As of v2.2, Flow Studio uses FastAPI exclusively. The legacy Flask backend has been archived.
docs/archive/PHASE_6_ADOPTION.md:79:  - Flask legacy code archived under `swarm/tools/_archive/flow_studio_flask_legacy.py`
docs/ROADMAP_2_4.md:27:- [ ] **Quick context load** — Pre-built context snapshots for common scenarios (greenfield, monorepo, legacy codebase)
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:17:Flask is no longer "deprecated" or "legacy" — it's **quarantined and impossible to accidentally use**.
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:26:- ✅ Flask backend archived: `swarm/tools/_archive/flow_studio_flask_legacy.py`
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:27:- ✅ Selftest excludes `_archive/` from compile checks (`swarm/tools/selftest_config.py:148`)
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:35:- `test_flask_only_in_archive()` — Verifies Flask is isolated
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:39:- `test_archive_structure_is_valid()` — Confirms archive integrity
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:40:- `test_no_active_imports_from_archive()` — Blocks imports from archived code
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:53:- `test_legacy_flask_file_is_not_executable()` — Confirms Flask is non-active
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:97:- **Deprecated**: Flask backend archived at `swarm/tools/_archive/flow_studio_flask_legacy.py`
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:144:- Flask code in `_archive/` directory
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:145:- Selftest compile excludes `_archive/` via `-x '_archive'` flag
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:177:   rm -rf swarm/tools/_archive/
docs/archive/FASTAPI_MIGRATION_COMPLETE.md:262:- Flask is **quarantined**, not just deprecated
tests/test_gemini_backend.py:227:    def test_maps_legacy_text_event(self) -> None:
tests/test_gemini_backend.py:228:        """Maps legacy text event from stub."""
swarm/FLOW_STUDIO.md:5:> **Note**: As of v2.2, Flow Studio uses FastAPI exclusively. The legacy Flask backend has been archived. If you're using `templates/flowstudio-only`, this does not affect you—that template continues to use Flask independently.
swarm/tools/run_inspector.py:199:        Falls back to legacy implementation if RunService is unavailable.
swarm/tools/run_inspector.py:210:                include_legacy=True,
swarm/tools/run_inspector.py:235:                filtered_tags = [t for t in summary.tags if t not in ("example", "legacy")]
swarm/tools/run_inspector.py:243:            # Fall back to legacy implementation
swarm/tools/run_inspector.py:244:            return self._list_runs_legacy()
swarm/tools/run_inspector.py:246:    def _list_runs_legacy(self) -> list[dict]:
swarm/tools/flow_studio_ui/js/domain.d.ts:347: * The API may return legacy values (GREEN/YELLOW/RED/UNKNOWN) which should be
swarm/tools/flow_studio_ui/js/governance_ui.js:17: * Normalize legacy selftest status (GREEN/YELLOW/RED/UNKNOWN) to the 4-state model.
swarm/tools/flow_studio_ui/js/governance_ui.js:28:    const legacyMap = {
swarm/tools/flow_studio_ui/js/governance_ui.js:34:    // Check if it's a legacy value
swarm/tools/flow_studio_ui/js/governance_ui.js:35:    if (status in legacyMap) {
swarm/tools/flow_studio_ui/js/governance_ui.js:36:        return legacyMap[status];
swarm/tools/flow_studio_ui/js/governance_ui.js:599:    // Normalize selftest status to the 4-state model (handles both legacy and new formats)
swarm/flowstudio/core.py:380:                include_legacy=True,
swarm/flowstudio/core.py:405:                filtered_tags = [t for t in summary.tags if t not in ("example", "legacy")]
tests/test_no_flask_in_runtime.py:10:- Excludes swarm/tools/_archive/ (archived legacy code)
tests/test_no_flask_in_runtime.py:12:- Verifies archival completeness (legacy Flask code is isolated)
tests/test_no_flask_in_runtime.py:34:    Scans all .py files in swarm/tools/ directory, excluding _archive/,
tests/test_no_flask_in_runtime.py:42:    # Collect all .py files, excluding _archive/
tests/test_no_flask_in_runtime.py:77:        error_msg += "\nFlask should only be in swarm/tools/_archive/"
tests/test_no_flask_in_runtime.py:81:def test_flask_only_in_archive():
tests/test_no_flask_in_runtime.py:82:    """Verify Flask code exists only in _archive/ subdirectory.
tests/test_no_flask_in_runtime.py:84:    The archived Flask implementation should be isolated in _archive/ and
tests/test_no_flask_in_runtime.py:88:    archive_dir = tools_dir / "_archive"
tests/test_no_flask_in_runtime.py:91:    assert archive_dir.exists(), "swarm/tools/_archive/ should exist as migration marker"
tests/test_no_flask_in_runtime.py:92:    assert archive_dir.is_dir(), "_archive should be a directory"
tests/test_no_flask_in_runtime.py:94:    # Flask legacy file should be in archive
tests/test_no_flask_in_runtime.py:95:    flask_legacy = archive_dir / "flow_studio_flask_legacy.py"
tests/test_no_flask_in_runtime.py:96:    assert flask_legacy.exists(), (
tests/test_no_flask_in_runtime.py:97:        "Archived Flask implementation should exist at swarm/tools/_archive/flow_studio_flask_legacy.py"
tests/test_no_flask_in_runtime.py:101:    content = flask_legacy.read_text(encoding="utf-8")
tests/test_no_flask_in_runtime.py:108:    """Verify no Flask in swarm/tools/ subdirectories (except _archive/).
tests/test_no_flask_in_runtime.py:115:    # Collect all .py files in subdirectories, excluding _archive/
tests/test_no_flask_in_runtime.py:119:        if subdir.name == "_archive":
tests/test_no_flask_in_runtime.py:142:def test_archive_structure_is_valid():
tests/test_no_flask_in_runtime.py:143:    """Verify _archive/ directory has expected structure.
tests/test_no_flask_in_runtime.py:145:    The archive should contain legacy code and __pycache__, but not be
tests/test_no_flask_in_runtime.py:148:    archive_dir = repo_root / "swarm" / "tools" / "_archive"
tests/test_no_flask_in_runtime.py:150:    # Should contain the legacy Flask file
tests/test_no_flask_in_runtime.py:151:    expected_files = ["flow_studio_flask_legacy.py"]
tests/test_no_flask_in_runtime.py:157:def test_no_active_imports_from_archive():
tests/test_no_flask_in_runtime.py:158:    """Verify no active code imports from _archive/.
tests/test_no_flask_in_runtime.py:160:    Active production code should never import from the _archive/ directory,
tests/test_no_flask_in_runtime.py:165:    # Get all .py files in active tools (excluding _archive)
tests/test_no_flask_in_runtime.py:171:        # Check for imports from _archive
tests/test_no_flask_in_runtime.py:172:        if "from swarm.tools._archive" in content or "from swarm.tools._archive import" in content:
tests/test_no_flask_in_runtime.py:174:                f"Active code should not import from _archive: {py_file.name}"
tests/test_no_flask_in_runtime.py:229:def test_legacy_flask_file_is_not_executable():
tests/test_no_flask_in_runtime.py:234:    flask_legacy = repo_root / "swarm" / "tools" / "_archive" / "flow_studio_flask_legacy.py"
tests/test_no_flask_in_runtime.py:236:    assert flask_legacy.exists(), "Legacy Flask file should exist in archive"
tests/test_no_flask_in_runtime.py:239:    # We verify this by checking it's in _archive/, not by permission checks
tests/test_no_flask_in_runtime.py:241:    assert "_archive" in str(flask_legacy), (
tests/test_no_flask_in_runtime.py:242:        "Flask file should be in _archive/ directory to signal non-active status"
tests/test_flow_studio_fastapi_only.py:39:    # Flask should not be in dependencies (might be in optional-dependencies for legacy support)
tests/test_flow_studio_fastapi_only.py:53:def test_flow_studio_py_archived():
tests/test_flow_studio_fastapi_only.py:54:    """Verify old Flask flow_studio.py is gone and legacy is under _archive/."""
tests/test_flow_studio_fastapi_only.py:57:        repo_root / "swarm" / "tools" / "_archive" / "flow_studio_flask_legacy.py"
tests/test_flow_studio_fastapi_only.py:66:        "swarm/tools/_archive/flow_studio_flask_legacy.py for reference."
swarm/tools/flow_studio_ui/index.html:4920: * Normalize legacy selftest status (GREEN/YELLOW/RED/UNKNOWN) to the 4-state model.
swarm/tools/flow_studio_ui/index.html:4931:    const legacyMap = {
swarm/tools/flow_studio_ui/index.html:4937:    // Check if it's a legacy value
swarm/tools/flow_studio_ui/index.html:4938:    if (status in legacyMap) {
swarm/tools/flow_studio_ui/index.html:4939:        return legacyMap[status];
swarm/tools/flow_studio_ui/index.html:5502:    // Normalize selftest status to the 4-state model (handles both legacy and new formats)
swarm/tools/flow_studio_ui/src/governance_ui.ts:29: * Normalize legacy selftest status (GREEN/YELLOW/RED/UNKNOWN) to the 4-state model.
swarm/tools/flow_studio_ui/src/governance_ui.ts:40:  const legacyMap: Record<LegacySelftestStatus, NormalizedSelftestStatus> = {
swarm/tools/flow_studio_ui/src/governance_ui.ts:47:  // Check if it's a legacy value
swarm/tools/flow_studio_ui/src/governance_ui.ts:48:  if (status in legacyMap) {
swarm/tools/flow_studio_ui/src/governance_ui.ts:49:    return legacyMap[status as LegacySelftestStatus];
swarm/tools/flow_studio_ui/src/governance_ui.ts:686:  // Normalize selftest status to the 4-state model (handles both legacy and new formats)
swarm/tools/flow_studio_ui/src/domain.ts:647: * The API may return legacy values (GREEN/YELLOW/RED/UNKNOWN) which should be
